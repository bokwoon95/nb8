schema.go
fs.go
notebrew.go
error.go
template.go
signup.go
login.go
logout.go
resetpassword.go
folder.go
file.go
...
server.go
notebrew/main.go

notebrew -dir ~/Dropbox/notebrew-admin
notebrew -db file://path/to/file/
notebrew -db postgres://user:pass@locahost:port/db
notebrew -db mysql://localhost
notebrew -db sqlite://notebrew.db
notebrew -dir ~/Dropbox/notebrew-admin -db sqlite -multisite subdomain

notebrew -config-folder
sqlite3 ~/notebrew.db

default dir: $HOME/notebrew-admin
default config? $HOME/notebrew-config
notebrew.db lives in uh ~/notebrew-config? ~/notebrew-admin? ~/notebrew.db?
notebrew-config.txt => ~/Dropbox/notebrew-config/

static/dynamic private/public config:
- static private: database.json, dns01.json, smtp.json, s3.json
- static public: admin-folder.txt domain.txt, content-domain.txt, multisite.txt
- dynamic private: captcha.json
- dynamic public: allow-signup.txt

notebrew config
Ctrl+C to stop anytime. Press enter without typing anything if you are satisfied with the current (or default) value.
config folder?
admin folder? (the admin folder is where X are stored. the current value is)
configure database? (database currently not configured):
    database dialect?
    sqlite file location?
    database host?
    database port?
    database user?
    database name?
    database password?
domain?
content domain? (content domain is currently not configured):
multisite?
allow signups?
captcha (y/n)?
    captcha site key?
    captcha secret key?
smtp (y/n)?
dns01 (y/n)?
s3 (y/n)? (if s3 not configured and the admin-folder is the database, use ~/notebrew-objects instead)

dialect
user
password
host
port
dbname
sslmode

just... dump everything in the admin folder? but you really don't want to back up the admin folder then because it contains sensitive secrets :(
then... use two folders?

notebrew-admin

dns01.json
captcha.json
smtp.json

TODO: come up with a good set of utility functions that seamlessly represent file operations so that you can queue them up effortlessly to use for testing ("first create this file, then create this folder, then..." etc). We need to do a lot of file operations to replicate the use cases we are testing, so better make this painless (and readable!)
TODO: mailer.json instead of mailer.txt, that way users don't have to urlencode their password to put it in the smtp URL.
TODO: what may a user want to display in a posts.html? A daily comic series, photography showcase, full blown posts, etc? We never let the user make an N+1 query, whatever fields they want must be supplied inside the call to getPosts. They get to cap how many posts are displayed per page via pagination.json/rss.json (ugh) in the category folder, which is stored in the files.data field.

notebrew encrypt -key $KEY $MESSAGE
notebrew decrypt
notebrew decrypt 'ABCDEFHGH' | notebrew
notebrew -config '{"domain":"bokwoon.com"}'
notebrew -config $(cat config.json | notebrew decrypt -key $NOTEBREW_SECRET_KEY)

-dir :database: -database "$HOME/notebrew.db" -multisite subdomain -address notebrew.com,notebrew.io

www.nbrew.io nuances
- only serves stuff in {sitePrefix}/output/themes
- if requested URL is a HTML page, issue a permanent redirect to that site's URL instead
- this is to prevent the same page from being available on multiple sources e.g. www.nbrew.io/@bokwoon and bokwoon.nbrew.io
- cdn.nbrew.io behaves identically to www.nbrew.io except cdn.nbrew.io may use a DNS CNAME record to point it to an actual CDN URL. If no CDN service is set up, cdn.nbrew.io gracefully degrades to serving files identical to www.nbrew.io.

nbrew.io/themes/ => https://cdn.nbrew.io/themes/
bokwoon.nbrew.io/themes/ => https://cdn.nbrew.io/@bokwoon/themes/
bokwoon.com/themes/ => https://cdn.nbrew.io/bokwoon.com/themes/

type Config struct{
    FS        FS
    DB        *sql.DB
    Dialect   string
    ErrorCode func(error) string
}

func New(config Config) (*Notebrew, error)

expose Automigrate as a public function, no longer call automigrate automatically
